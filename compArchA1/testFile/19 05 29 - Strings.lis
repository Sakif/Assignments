X-Makina Assembler - Version 2.1 (29 May 2019)
.ASM file: 19 05 29 - Strings.asm
Time of execution: Wed May 29 06:35:49 2019


  1	    	     	;
  2	    	     	; Example X-Makina program
  3	    	     	; Assembling two string functions (strlen() and strcpy())
  4	    	     	; Called by mainline
  5	    	     	; L. Hughes
  6	    	     	; 28 May 2019 - Rewrite to XM2
  7	    	     	; 11 Jun 2018 - Second example of storing length using relative addressing
  8	    	     	; 11 May 2018 - Initial release
  9	    	     	;
 10	    	     	STKTOP	equ	$FFC0	; Top-of-stack - PUSH (decr then write); PULL (read then incr)
 11	    	     	NUL	equ	'\0'	; End-of-string indicator
 12	    	     	; 
 13	    	     	r2	equ	R2	; r2 is alias of R2
 14	    	     	LR	equ	R4	; LR is alias of R4
 15	    	     	SP	equ	R5	; SP is alias of R5 
 16	    	     	PC	equ	R7	; PC is alias of R7
 17	    	     	;
 18	    	     	; Code space
 19	    	     		org	$100
 20	    	     	Main
 21	    	     	; Initialize stack point
 22	0100	7605		movls	STKTOP,SP	; STKTOP.LSB to SP.LSB; $FF to SP.MSB
 23	    	     	;
 24	    	     	; R1 points to string
 25	0102	6011		movl	MyStr,R1
 26	0104	7981		movh	MyStr,R1
 27	    	     	; Call strlen()
 28	0106	0007		bl	strlen	; R1 points to string; R0 returned with length
 29	    	     	;
 30	    	     	; Two examples of storing (R0, length, in MSLen):
 31	    	     	;
 32	    	     	; 1. Indexed using R1 (address of MyStr)
 33	0108	4291		sub	#2,R1	; Word before MyStr is MSLen
 34	010A	5481		st.w	R0,R1+	; Save R0 in MSLen
 35	    	     				; Bit of a cheat - increment R1 by 2 to point 
 36	    	     				; back to string MyStr
 37	    	     	;
 38	    	     	; 2. Relative using offset "back" from R1 to MSLen's location
 39	010C	FF01		str.w	R0,R1,#-2; mem[R1-2] = R0
 40	    	     				; Note that R1 is unchanged
 41	    	     	;
 42	    	     	; Call strcpy()
 43	    	     	; MyStr (R1) to Str2 (r2)
 44	    	     	; Setup destination str in R2
 45	010E	6052		movl	Str2,r2
 46	0110	7982		movh	Str2,r2
 47	    	     	;
 48	0112	0F76		bl	strcpy	; LR holds return address
 49	    	     	;
 50	    	     	; No halt, loop until ^C
 51	    	     	;
 52	    	     	Done	
 53	0114	3FFF		bra	Done
 54	    	     	;
 55	    	     	; String length function
 56	    	     	; Input: R1 - Address of NUL-terminated string
 57	    	     	; Returns: Length of string in R0
 58	    	     	strlen
 59	    	     	; 
 60	0116	570D		st	R1,-SP	; Push R1 (to restore on exit)
 61	0118	5715		st	R2,-SP	; Push R2 (holds character read)
 62	011A	6800		movlz	#0,R0	; Return length in R0 (initially zero)
 63	    	     	;
 64	    	     	strlen1	
 65	011C	50CA		ld.b	R1+,R2	; Copy byte [R1] to R2 and R1 incremented by 1
 66	011E	45C2		cmp.b	NUL,R2	; Compare byte (in R2) with NUL
 67	0120	2002		beq	strlen2	; If equal, go to strlen2
 68	0122	4088		add	#1,R0	; R0 (length) incremented by 1
 69	0124	3FFB		bra	strlen1	; Check next byte
 70	    	     	;
 71	    	     	; Finished
 72	    	     	strlen2	
 73	0126	50AA		ld	SP+,R2	; Pull R2
 74	0128	50A9		ld	SP+,R1	; Pull R1
 75	012A	4B27		mov	LR,PC	; Return to caller.  R0 has length
 76	    	     	;
 77	    	     		org	$2000
 78	    	     	;
 79	    	     	; String copy function
 80	    	     	; Input: R1 - src string; R2 - dst string
 81	    	     	; R0 holds char - stop when NUL
 82	    	     	; No check on length of dst string
 83	    	     	; Returns: nothing
 84	    	     	strcpy
 85	2000	5705		st	R0,-SP	; Push R0
 86	2002	570D		st	R1,-SP	; Push R1
 87	2004	5715		st	R2,-SP	; Push R2
 88	    	     	;
 89	2006	4B83		mov	#0,R3
 90	    	     	;
 91	    	     	strcpy1
 92	2008	408B		add	#1,R3
 93	200A	50C8		ld.b	R1+,R0	; ch = src[i++]
 94	200C	54C2		st.b	R0,R2+	; dst[j++] = ch (includes NUL)
 95	200E	47F8		and.b	#-1,R0
 96	    	     		; cmp.b	NUL,R0	; ch = NUL? - AND sets PSW flags - no need for CMP
 97	2010	27FB		bne	strcpy1	; No - do next ch
 98	    	     	;
 99	    	     	; NUL found - restore registers and return
100	2012	50AA		ld	SP+,R2	; Pull R2
101	2014	50A9		ld	SP+,R1	; Pull R1
102	2016	50A8		ld	SP+,R0	; Pull R0
103	2018	4B27		mov	LR,PC	; return to caller
104	    	     	;
105	    	     	; Data space 
106	    	     	; Setting the origin could be unsafe - if code addresses extend past $1000, they
107	    	     	; could be overwritten by the data.  This is one argument for a linker.
108	    	     	;
109	    	     		org	$3000
110	    	     	;
111	3000	0000	MSLen	bss	#2	; Reserve 2 bytes (word) for length of MyStr
112	3002	0054	MyStr	byte	'T'	; The assembler needs a string directive...
113	3003	0068		byte	'h'
114	3004	0065		byte	'e'
115	3005	0020		byte	' '
116	3006	0063		byte	'c'
117	3007	0061		byte	'a'
118	3008	0074		byte	't'
119	3009	0000		byte	NUL
120	    	     	;
121	300A	0000	Str2	bss	#100	; 100 bytes for destination string
122	    	     	;
123	    	     		end	Main
Successful completion of assembly

** Symbol table **
Name                               	Type	Value	Decimal
MSLen                              	LBL	3000	12288
strcpy1                            	LBL	2008	8200
strlen2                            	LBL	0126	294
strlen1                            	LBL	011C	284
Done                               	LBL	0114	276
strcpy                             	LBL	2000	8192
Str2                               	LBL	300A	12298
strlen                             	LBL	0116	278
MyStr                              	LBL	3002	12290
Main                               	LBL	0100	256
PC                                 	REG	0007	7
SP                                 	REG	0005	5
LR                                 	REG	0004	4
r2                                 	REG	0002	2
NUL                                	LBL	0000	0
STKTOP                             	LBL	FFC0	-64
R7                                 	REG	0007	7
R6                                 	REG	0006	6
R5                                 	REG	0005	5
R4                                 	REG	0004	4
R3                                 	REG	0003	3
R2                                 	REG	0002	2
R1                                 	REG	0001	1
R0                                 	REG	0000	0

.XME file: C:\Users\Larry\OneDrive\Courses\ECED 3403\2019\Examples\A1 - First Pass testing\19 05 29 - Strings.xme

